<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=utf-8" http-equiv="content-type">
<title>ImageFlow Project Documentation - Basics</title>


<style>
<!-- 
h1 {
	font-family:Helvetica, Arial;
	color:#224488;
	font-size:14pt;}
	
pre, 
.codeName {
	font-family: monospace;
}
-->
</style>

</head>
<body>
<h1>Imageflow Project Documentation</h1>
<h2>Appframework</h2>
<p>To understand how the application is working, it is important to understand what the Appframework is doing.</p>
<h3>General</h3>
<p>During the production of every application comes a point where the programmer is faced with the same general problems. 
How to handle resources and localization? How to handle threads? How to deal with actions and threads? 
What is the basic data structure, Model-View-Controller? <br />
Most programmers develop their own solutions over time and reuse them in their programs. The 
disadvantages are, 
that for common problems, many different solutions were implemented and everybody cooked by their own recipy. Secondly, 
these solutions contain only the experience of one programmer and the problems he faced before. 
Anticipating problems is naturally difficult. </p>
<p>For this reason, I didn't want to base this application on my earlier programs, but instead on a 
general purpose
desktop application framework. This framework was supposed to give a skeleton 
for the model-controller structure, resource management, thread handling 
and action-handling. <a href="https://appframework.dev.java.net" title="Appframework Website">
Appframework</a> developed as <a href="http://jcp.org/en/jsr/detail?id=296" title="Specifikation">
Specification JSR-296</a> 
by Sun. The framework was specified in 2006 and has been in development since then. 
It was scheduled to be included in Java7 and by 2008 it was already included NetBeans.</p>

<h3>Action-handling</h3>
<p>Java's Action-Interface describes a class, which contains one specific action, that is performed 
by the use 
from somewhere in the GUI. Usual cases are menu-entries, toolbar-entries, buttons or hotkeys. 
The Action-interface allows
to create one class for handling. If you disable the action, this is resembled everywhere this 
action is used in the GUI. This 
makes it very easy to deal with actions.</p>
<p>However there are a few drawbacks. You have to implement the Interface yourself. You can still 
create many instances of one
action, although every Action should be treated like a Singleton. Mixing Actions with Resources can be done easily, but there are 
no best-practice rules. <br />
Appframework gives straight rules on how to define and use actions. These are defined very differently.</p>
<p>In your project you have a view, for example a Frame of your programm. Within this frame you 
have the menus, buttons etc, which
shall have an assigned Action. You defined this action by creating a new method, which is preceded by the 
<a href="https://appframework.dev.java.net/nonav/javadoc/AppFramework-1.03/index.html" 
title="Action Annotation">Annotation <span class="codeName">@Action</span><a>. Using Reflection based on the method name, 
the framework creates an Action-object with the method's contents taken as the 
<span class="codeName">actionPerformed()</span>-method.
This object is automatically put into the ActionMap, a singleton-map, which contains all created actions of this Frame.
You can identify the action by the name of the method, retrieve it from the map and simply add it to the
button like you would with your own Action-implementation. For a bit convenience I use this methods:</p>
<pre>
private javax.swing.Action getAction(String actionName) {
	ActionMap actionMap = getContext().getActionMap(ImageFlowView.class, this);
    return actionMap.get(actionName);
}
</pre> 
<p>Note that the <span class="codeName">ImageFlowView</span> describes the class we want to get the ActionMap from. In theory
you can a uniqe ActionMap for every view.<br />
A common Action-definition in a <span class="codeName">AppView</span>-Class could look like this:</p>
<pre>
@Action
public Task doSomething() {
	System.out.println("Print something");
	return new DoesSomethingTask();
}
</pre>
<p><span class="codeName">@Action</span> can have two Attributes. <span class="codeName">enabledProperty</span> can bind the 
enabled-property of the Action with a boolean-field by the same name. <span class="codeName">selectedProperty</span> does the same for the selected-property. 
 
<pre>
boolean enabled = true;
@Action (enabledProperty = "enabled")
public Task doSomething() { ... }
</pre>

<h3>Resource-Management</h3>

<p>Every view or frame can have it's own property-file, which contains single key-value-pairs for resources. 
To remain with our example. The Action we created in the section above is included in the properties-files of the 
frame, in which it is defined. By convention the properties-files are in a subpackage <em>resources</em> and by the
same name as the frame. Inside the file you can use the Action's name as key to set up different values.</p>

<p>The <em>AppView.properties</em> of our example above may look like this:</p>  
<pre>
doSomething.Action.text = Paste
doSomething.Action.accelerator = shortcut V
doSomething.Action.shortDescription = Paste the Unit in the clipboard to the workflow.
doSomething.Action.icon=icon.png
</pre>

<p>This can also be used for any other kind of text or path.</p>


<h3>Thread-handling</h3>

<p></p>

<hr />
<em>Daniel Senff, July-August 2009</em>
</body></html>